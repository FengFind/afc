/*
 * $Id$
 * 
 * Copyright (c) 2008-09, Multiagent Team - Systems and Transportation Laboratory (SeT)
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of the Systems and Transportation Laboratory ("Confidential Information").
 * You shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with the SeT.
 * 
 * http://www.multiagent.fr/
 */
package fr.utbm.set.jasim.network;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.net.BindException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import javax.vecmath.Point2d;
import javax.vecmath.Point3d;
import javax.vecmath.Quat4d;
import javax.vecmath.Vector3d;

import org.arakhne.afc.util.OutputParameter;

import fr.utbm.set.geom.system.CoordinateSystem3D;
import fr.utbm.set.io.endian.EndianUtil;
import fr.utbm.set.jasim.network.data.GroundInfo;
import fr.utbm.set.jasim.network.data.MobileEntityMoveInfo;
import fr.utbm.set.jasim.network.data.MobileEntitySpawningInfo;
import fr.utbm.set.jasim.network.data.PlaceInfo;
import fr.utbm.set.jasim.network.data.ProbeDescription;
import fr.utbm.set.jasim.network.data.ProbeIdentifier;
import fr.utbm.set.jasim.network.data.ProbeInfo;
import fr.utbm.set.jasim.network.data.SimulationConfiguration;
import fr.utbm.set.jasim.network.data.SimulationInfo;
import fr.utbm.set.math.AngularUnit;
import fr.utbm.set.math.SpaceUnit;
import fr.utbm.set.math.SpeedUnit;

/**
 * Abstract implements of a JaSIM network connection.
 * It is providing a set of usefull functions.
 * 
 * @author $Author: sgalland$
 * @author $Author: ngaud$
 * @author $Author: rzeo$
 * @version $Name$ $Revision$ $Date$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
public abstract class AbstractJaSIMNetworkConnection implements NetworkInterfaceConstants {

	/** This constant permits to the compiler to remove
	 * the associated source code from the generated byte code
	 * (see Java specifications for details).
	 */
	public static final boolean DEBUG = false;
	
	/** Stream from which the data are red.
	 */
	protected DataInputStream inputStream = null;

	/** Stream in which the data are written.
	 */
	protected DataOutputStream outputStream = null;

	/**
	 */
	protected AbstractJaSIMNetworkConnection() {
		//
	}

	/** Read the message header.
	 *  
	 * @return the type of the message, never <code>null</code>
	 * @throws IOException
	 */
	protected NetworkMessageType readMessageHeader() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		if (this.inputStream.readInt() != JASIM_MESSAGE_CODE) throw new IOException("not a JaSIM message"); //$NON-NLS-1$
		int code = this.inputStream.readInt();
		NetworkMessageType type = NetworkMessageType.fromJaSIMCode(code);
		if (type==null) throw new IOException("unsupported JaSIM message type: "+code); //$NON-NLS-1$)
		return type;			
	}
		
	/** Read a string value.
	 * 
	 * @return a string, never <code>null</code>
	 * @throws IOException
	 */
	protected String readString() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		int length = this.inputStream.readInt();
		if (length>0) {
			byte[] buffer = new byte[length];
			this.inputStream.readFully(buffer);
			return new String(buffer);
		}
		return ""; //$NON-NLS-1$
	}
	
	/** Read an URL value.
	 * 
	 * @return an URL, never <code>null</code>
	 * @throws IOException
	 * @throws MalformedURLException
	 */
	protected URL readURL() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		String externalForm = readString();
		try {
			return new URL(externalForm);
		}
		catch(MalformedURLException _) {
			return new File(externalForm).toURI().toURL();
		}
	}

	/** Read an unique identifier.
	 * 
	 * @return an UUID, never <code>null</code>
	 * @throws IOException
	 */
	protected UUID readUUID() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		int length = this.inputStream.readInt();
		if (length>0) {
			byte[] buffer = new byte[length];
			this.inputStream.readFully(buffer);
			try {
				return UUID.fromString(new String(buffer));
			}
			catch(Throwable e) {
				throw new IOException("invalid UUID: [" //$NON-NLS-1$
						+length+"]" //$NON-NLS-1$
						+new String(buffer), e);
			}
		}
		throw new IOException("no UUID available"); //$NON-NLS-1$
	}
		
	/** Read a variant value.
	 *  
	 * @return the extracted data, never <code>null</code>
	 * @throws IOException
	 */
	protected Serializable readVariant() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		
		byte typeCode = this.inputStream.readByte();
		VariantType type = VariantType.fromByteValue(typeCode);
		if (type==null) throw new IOException("unsupported variant type: "+typeCode); //$NON-NLS-1$
		
		int dataLength = this.inputStream.readInt();
		int bufferLength = dataLength;
		
		if (type==VariantType.BOOLEAN_ARRAY) {
			bufferLength = (int)Math.ceil(dataLength/8.);
		}
		
		byte[] buffer = new byte[bufferLength];
		this.inputStream.readFully(buffer);

		switch(type) {
		case BOOLEAN:
			if (dataLength!=1) throw new IOException("invalid variant size specified: "+dataLength+", expected: 1"); //$NON-NLS-1$ //$NON-NLS-2$
			return (boolean)(buffer[0]!=0);

		case BYTE:
			if (dataLength!=1) throw new IOException("invalid variant size specified: "+dataLength+", expected: 1"); //$NON-NLS-1$ //$NON-NLS-2$
			return (byte)(buffer[0]);
			
		case CHARACTER:
			if (dataLength!=1) throw new IOException("invalid variant size specified: "+dataLength+", expected: 1"); //$NON-NLS-1$ //$NON-NLS-2$
			return (char)(buffer[0]);

		case INTEGER:
			if (dataLength!=4) throw new IOException("invalid variant size specified: "+dataLength+", expected: 4"); //$NON-NLS-1$ //$NON-NLS-2$
			return EndianUtil.toBEInt(buffer[0], buffer[1], buffer[2], buffer[3]);
			
		case FLOAT:
			if (dataLength!=8) throw new IOException("invalid variant size specified: "+dataLength+", expected: 8"); //$NON-NLS-1$ //$NON-NLS-2$
			return EndianUtil.toBEDouble(buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]);

		case POINT:
			if (dataLength!=24) throw new IOException("invalid variant size specified: "+dataLength+", expected: 24"); //$NON-NLS-1$ //$NON-NLS-2$
			{ 
				double x = EndianUtil.toBEDouble(buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]);
				double y = EndianUtil.toBEDouble(buffer[8], buffer[9], buffer[10], buffer[11], buffer[12], buffer[13], buffer[14], buffer[15]);
				double z = EndianUtil.toBEDouble(buffer[16], buffer[17], buffer[18], buffer[19], buffer[20], buffer[21], buffer[22], buffer[23]);
				return new Point3d(x,y,z);
			}
			
		case VECTOR:
			if (dataLength!=24) throw new IOException("invalid variant size specified: "+dataLength+", expected: 24"); //$NON-NLS-1$ //$NON-NLS-2$
			{
				double x = EndianUtil.toBEDouble(buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]);
				double y = EndianUtil.toBEDouble(buffer[8], buffer[9], buffer[10], buffer[11], buffer[12], buffer[13], buffer[14], buffer[15]);
				double z = EndianUtil.toBEDouble(buffer[16], buffer[17], buffer[18], buffer[19], buffer[20], buffer[21], buffer[22], buffer[23]);
				return new Vector3d(x,y,z);
			}

		case QUATERNION:
			if (dataLength!=32) throw new IOException("invalid variant size specified: "+dataLength+", expected: 32"); //$NON-NLS-1$ //$NON-NLS-2$
			{
				double x = EndianUtil.toBEDouble(buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]);
				double y = EndianUtil.toBEDouble(buffer[8], buffer[9], buffer[10], buffer[11], buffer[12], buffer[13], buffer[14], buffer[15]);
				double z = EndianUtil.toBEDouble(buffer[16], buffer[17], buffer[18], buffer[19], buffer[20], buffer[21], buffer[22], buffer[23]);
				double w = EndianUtil.toBEDouble(buffer[24], buffer[25], buffer[26], buffer[27], buffer[28], buffer[29], buffer[30], buffer[31]);
				return new Quat4d(x,y,z,w);
			}

		case BOOLEAN_ARRAY:
			{
				boolean[] values = new boolean[dataLength];
				for(int i=0, j=0; i<buffer.length; ++i) {
					for(int d=7; d>=0; --d, ++j) {
						values[j] = (buffer[i] & (1>>d))!=0;
					}
				}
				return values;
			}

		case BYTE_ARRAY:
			return buffer;

		case CHARACTER_ARRAY:
			{
				char[] values = new char[dataLength];
				for(int i=0; i<values.length; ++i) {
					values[i] = (char)buffer[i];
				}
				return values;
			}

		case INTEGER_ARRAY:
			if (dataLength%4==0) throw new IOException("invalid variant size specified: "+dataLength+", expected multiple of: 4"); //$NON-NLS-1$ //$NON-NLS-2$
			{
				int valueCount = dataLength%4;
				int[] values = new int[valueCount];
				for(int i=0, j=0; i<values.length; ++i, j+=4) {
					values[i] = EndianUtil.toBEInt(buffer[j], buffer[j+1], buffer[j+2], buffer[j+3]);
				}
				return values;
			}
			
		case FLOAT_ARRAY:
			if (dataLength%8==0) throw new IOException("invalid variant size specified: "+dataLength+", expected multiple of: 8"); //$NON-NLS-1$ //$NON-NLS-2$
			{
				int valueCount = dataLength%8;
				double[] values = new double[valueCount];
				for(int i=0, j=0; i<values.length; ++i, j+=8) {
					values[i] = EndianUtil.toBEDouble(buffer[j], buffer[j+1], buffer[j+2], buffer[j+3], buffer[j+4], buffer[j+5], buffer[j+6], buffer[j+7]);
				}
				return values;
			}
			
		case STRING:
			return new String(buffer);
			
		case UUID:
			return UUID.fromString(new String(buffer));

		case URL:
			return new URL(new String(buffer));

		default:
			throw new IOException("unsupported variant type: "+type); //$NON-NLS-1$
		}
	}

	/** Read a named variant value.
	 *  
	 * @param name is the name of the variant value.
	 * @param value is the value of the variant value.
	 * @throws IOException
	 */
	protected void readVariant(OutputParameter<String> name, OutputParameter<Object> value) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		
		value.set(readVariant());
		
		name.set(readString());		
	}

	/** Write the message header.
	 *  
	 * @param type is the type of the message, never <code>null</code>
	 * @throws IOException
	 */
	protected void writeHeaderSection(NetworkMessageType type) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		
		if (DEBUG) {
			System.err.println("SEND "+type.name()+" ("+type.toJaSIMCode()+")"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		}
		
		this.outputStream.writeInt(JASIM_MESSAGE_CODE);
		this.outputStream.writeInt(type.toJaSIMCode());
	}

	/** Write a string.
	 *  
	 * @param string
	 * @throws IOException
	 */
	protected void writeString(String string) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		if (string==null) {
			this.outputStream.writeInt(0);
		}
		else {
			byte[] buffer = string.getBytes();
			this.outputStream.writeInt(buffer.length);
			this.outputStream.write(buffer);
		}
	}
	
	/** Write an URL.
	 *  
	 * @param url
	 * @throws IOException
	 */
	protected void writeURL(URL url) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		if (url==null) {
			this.outputStream.writeInt(0);
		}
		else {
			writeString(url.toExternalForm());
		}
	}

	/** Write the given UUID on the network link.
	 * 
	 * @param id is the identifier to send on network. It may not be <code>null</code>.
	 * @throws IOException
	 */
	protected void writeUUID(UUID id) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		if (id==null) {
			throw new IOException("no uuid to send on network"); //$NON-NLS-1$
		}

		String idString = id.toString();
		byte[] buffer = idString.getBytes();
		this.outputStream.writeInt(buffer.length);
		this.outputStream.write(buffer);
	}

	/** Write a variant value.
	 *  
	 * @param value
	 * @throws IOException
	 */
	protected void writeVariant(Object value) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		
		VariantType type = VariantType.NULL;
		int s = 0;
		byte[] buffer = null;

		if (value!=null) {
			if (value instanceof Point3d) {
				byte[] b;
				Point3d p = (Point3d)value;
				type = VariantType.POINT;
				s = 24;
				buffer = new byte[s];
				b = EndianUtil.parseBEDouble(p.x);
				System.arraycopy(b, 0, buffer, 0, b.length);
				b = EndianUtil.parseBEDouble(p.y);
				System.arraycopy(b, 0, buffer, 8, b.length);
				b = EndianUtil.parseBEDouble(p.z);
				System.arraycopy(b, 0, buffer, 16, b.length);
			}
			else if (value instanceof Vector3d) {
				byte[] b;
				Vector3d p = (Vector3d)value;
				type = VariantType.VECTOR;
				s = 24;
				buffer = new byte[s];
				b = EndianUtil.parseBEDouble(p.x);
				System.arraycopy(b, 0, buffer, 0, b.length);
				b = EndianUtil.parseBEDouble(p.y);
				System.arraycopy(b, 0, buffer, 8, b.length);
				b = EndianUtil.parseBEDouble(p.z);
				System.arraycopy(b, 0, buffer, 16, b.length);
			}
			else if (value instanceof Quat4d) {
				byte[] b;
				Quat4d p = (Quat4d)value;
				type = VariantType.QUATERNION;
				s = 32;
				buffer = new byte[s];
				b = EndianUtil.parseBEDouble(p.x);
				System.arraycopy(b, 0, buffer, 0, b.length);
				b = EndianUtil.parseBEDouble(p.y);
				System.arraycopy(b, 0, buffer, 8, b.length);
				b = EndianUtil.parseBEDouble(p.z);
				System.arraycopy(b, 0, buffer, 16, b.length);
				b = EndianUtil.parseBEDouble(p.w);
				System.arraycopy(b, 0, buffer, 24, b.length);
			}
			else if (value instanceof Character) {
				type = VariantType.CHARACTER;
				s = 1;
				buffer = new byte[] { (byte)((Character)value).charValue() };
			}
			else if (value instanceof Byte) {
				type = VariantType.BYTE;
				s = 1;
				buffer = new byte[] { ((Byte)value).byteValue() };
			}
			else if (value instanceof Short) {
				type = VariantType.INTEGER;
				s = 4;
				buffer = EndianUtil.parseBEInt(((Short)value).intValue());
			}
			else if (value instanceof Integer) {
				type = VariantType.INTEGER;
				s = 4;
				buffer = EndianUtil.parseBEInt(((Integer)value).intValue());
			}
			else if (value instanceof Long) {
				type = VariantType.INTEGER;
				s = 4;
				buffer = EndianUtil.parseBEInt(((Long)value).intValue());
			}
			else if (value instanceof Float) {
				type = VariantType.FLOAT;
				s = 8;
				buffer = EndianUtil.parseBEDouble(((Float)value).doubleValue());
			}
			else if (value instanceof Double) {
				type = VariantType.FLOAT;
				s = 8;
				buffer = EndianUtil.parseBEDouble(((Double)value).doubleValue());
			}
			else if (value instanceof UUID) {
				type = VariantType.UUID;
				buffer = value.toString().getBytes();
				s = buffer.length;
			}
			else if (value instanceof URL) {
				type = VariantType.URL;
				buffer = ((URL)value).toExternalForm().getBytes();
				s = buffer.length;
			}
			else if (value instanceof boolean[]) {
				boolean[] tab = (boolean[])value;
				type = VariantType.BOOLEAN_ARRAY;
				int tabSize = (int)Math.ceil(tab.length/8.);
				s = tab.length;
				buffer = new byte[tabSize];
				for(int i=0, j=0; i<tab.length; i+=8, ++j) {
					buffer[j] = 0;
					for(int k=i, d=7; k<tab.length && k<i+8; ++k, --d) {
						buffer[j] = (byte)(buffer[j] | ((tab[k] ? 1 : 0) << d));
					}
				}
			}
			else if (value instanceof byte[]) {
				type = VariantType.BYTE_ARRAY;
				buffer = (byte[])value;
				s = buffer.length;
			}
			else if (value instanceof char[]) {
				char[] tab = (char[])value;
				type = VariantType.CHARACTER_ARRAY;
				s = tab.length;
				buffer = new byte[s];
				for(int i=0; i<tab.length; ++i) {
					buffer[i] = (byte)tab[i];
				}
			}
			else if (value instanceof short[]) {
				short[] tab = (short[])value;
				byte[] b;
				type = VariantType.INTEGER_ARRAY;
				s = tab.length * 4;
				buffer = new byte[s];
				for(int i=0, j=0; i<s; i+=4, ++j) {
					b = EndianUtil.parseBEInt(tab[j]);
					System.arraycopy(b, 0, buffer, i, b.length);
				}
			}
			else if (value instanceof int[]) {
				int[] tab = (int[])value;
				byte[] b;
				type = VariantType.INTEGER_ARRAY;
				s = tab.length * 4;
				buffer = new byte[s];
				for(int i=0, j=0; i<s; i+=4, ++j) {
					b = EndianUtil.parseBEInt(tab[j]);
					System.arraycopy(b, 0, buffer, i, b.length);
				}
			}
			else if (value instanceof long[]) {
				long[] tab = (long[])value;
				byte[] b;
				type = VariantType.INTEGER_ARRAY;
				s = tab.length * 4;
				buffer = new byte[s];
				for(int i=0, j=0; i<s; i+=4, ++j) {
					b = EndianUtil.parseBEInt((int)tab[j]);
					System.arraycopy(b, 0, buffer, i, b.length);
				}
			}
			else if (value instanceof float[]) {
				float[] tab = (float[])value;
				byte[] b;
				type = VariantType.FLOAT_ARRAY;
				s = tab.length * 8;
				buffer = new byte[s];
				for(int i=0, j=0; i<s; i+=8, ++j) {
					b = EndianUtil.parseBEDouble(tab[j]);
					System.arraycopy(b, 0, buffer, i, b.length);
				}
			}
			else if (value instanceof double[]) {
				double[] tab = (double[])value;
				byte[] b;
				type = VariantType.FLOAT_ARRAY;
				s = tab.length * 8;
				buffer = new byte[s];
				for(int i=0, j=0; i<s; i+=8, ++j) {
					b = EndianUtil.parseBEDouble(tab[j]);
					System.arraycopy(b, 0, buffer, i, b.length);
				}
			}
			else if (value instanceof Serializable) {
				ByteArrayOutputStream baos = new ByteArrayOutputStream();
				ObjectOutputStream oos = new ObjectOutputStream(baos);
				oos.writeObject(value);
				buffer = baos.toByteArray();
				baos.close();
				type = VariantType.BYTE_ARRAY;
				s = buffer.length;
			}
			else {
				type = VariantType.STRING;
				buffer = value.toString().getBytes();
				s = buffer.length;
			}
		}
		
		this.outputStream.writeByte(type.ordinal());
		this.outputStream.writeInt(s);
		if (s>0) this.outputStream.write(buffer);
	}
	
	/** Write a variant value.
	 *  
	 * @param name
	 * @param value
	 * @throws IOException
	 */
	protected void writeVariant(String name, Object value) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeVariant(value);
		writeString(name);
	}

	/** Read the INIT message's variable-length content.
	 *  
	 * @return the extracted data, never <code>null</code>
	 * @throws IOException
	 */
	protected SimulationConfiguration readInitMessage() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$

		URL url = readURL();
		String xmlContent = readString();
		
		return new SimulationConfiguration(url, xmlContent);
	}

	/** Write the INIT message.
	 *  
	 * @param configuration
	 * @throws IOException
	 */
	protected void writeInitMessage(SimulationConfiguration configuration) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$

		writeHeaderSection(NetworkMessageType.INIT);
		
		writeURL(configuration.getSearchDirectory());
					
		writeString(configuration.getXMLConfiguration());
		this.outputStream.flush();
	}

	/** Read the ADD_PROBE message's variable-length content.
	 *  
	 * @return the extracted data, never <code>null</code>
	 * @throws IOException
	 */
	protected ProbeDescription readAddProbeMessage() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$

		UUID placeId = readUUID();

		String probeId = readString();

		String type = readString();

		int parameterCount = this.inputStream.readInt();
		Serializable[] parameters = new Serializable[parameterCount];
		if (parameterCount>0) {
			for(int i=0; i<parameterCount; ++i) {
				parameters[i] = readVariant();
			}
		}
		
		return new ProbeDescription(placeId, probeId, type, parameters);
	}

	/** Write the ADD_PROBE message.
	 *  
	 * @param description
	 * @throws IOException
	 */
	protected void writeAddProbeMessage(ProbeDescription description) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$

		writeHeaderSection(NetworkMessageType.ADD_PROBE);
		
		ProbeIdentifier id = description.getProbeId();		
		writeUUID(id.getPlaceId());
		writeString(id.getProbeName());

		writeString(description.getProbeType());

		int paramCount = description.getParameterCount();
		this.outputStream.writeInt(paramCount);
		for(int idxParam=0; idxParam<paramCount; ++idxParam) {
			writeVariant(description.getParameterAt(idxParam));
		}
		this.outputStream.flush();
	}

	/** Read the REMOVE_PROBE message's variable-length content.
	 *  
	 * @return the extracted data, never <code>null</code>
	 * @throws IOException
	 */
	protected ProbeIdentifier readRemoveProbeMessage() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$

		UUID placeId = readUUID();

		String probeId = readString();

		return new ProbeIdentifier(placeId, probeId);
	}

	/** Write the REMOVE_PROBE message.
	 *  
	 * @param identifier
	 * @throws IOException
	 */
	protected void writeRemoveProbeMessage(ProbeIdentifier identifier) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.REMOVE_PROBE);
		writeUUID(identifier.getPlaceId());
		writeString(identifier.getProbeName());
		this.outputStream.flush();
	}

	/** Write a spawning description for a mobile entity.
	 * 
	 * @param entity
	 * @throws IOException
	 */
	protected void writeEntityDescriptionSection(MobileEntitySpawningInfo entity) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeUUID(entity.getId());
		
		Point3d pt3d = entity.getPosition();
		this.outputStream.writeDouble(pt3d.x);
		this.outputStream.writeDouble(pt3d.y);
		this.outputStream.writeDouble(pt3d.z);
		
		Vector3d vt3d = entity.getPivot();
		this.outputStream.writeDouble(vt3d.x);
		this.outputStream.writeDouble(vt3d.y);
		this.outputStream.writeDouble(vt3d.z);
		
		Quat4d q4d = entity.getOrientation();
		this.outputStream.writeDouble(q4d.x);
		this.outputStream.writeDouble(q4d.y);
		this.outputStream.writeDouble(q4d.z);
		this.outputStream.writeDouble(q4d.w);

		writeString(entity.getBodyType());
		this.outputStream.flush();
	}
	
	/** Read a spawning description for a mobile entity.
	 * 
	 * @return the entity description
	 * @throws IOException
	 */
	protected MobileEntitySpawningInfo readEntityDescriptionSection() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$

		UUID entityId = readUUID();
		
		Point3d position = new Point3d();		
		position.x = this.inputStream.readDouble();
		position.y = this.inputStream.readDouble();
		position.z = this.inputStream.readDouble();
		
		Vector3d pivot = new Vector3d();		
		pivot.x = this.inputStream.readDouble();
		pivot.y = this.inputStream.readDouble();
		pivot.z = this.inputStream.readDouble();
		
		Quat4d orientation = new Quat4d();		
		orientation.x = this.inputStream.readDouble();
		orientation.y = this.inputStream.readDouble();
		orientation.z = this.inputStream.readDouble();
		orientation.w = this.inputStream.readDouble();

		String bodyType = readString();
		
		return new MobileEntitySpawningInfo(entityId, position, pivot, orientation, bodyType);
	}

	/** Write a MOVE_ACTION content.
	 * 
	 * @param index is the action index
	 * @param move
	 * @throws IOException
	 */
	protected void writeMoveActionSection(int index, MobileEntityMoveInfo move) throws IOException {
		this.outputStream.writeByte(0); // Move action
		
		writeUUID(move.getId());
		
		Vector3d vt3d = move.getLastMove();
		this.outputStream.writeDouble(vt3d.x);
		this.outputStream.writeDouble(vt3d.y);
		this.outputStream.writeDouble(vt3d.z);
		
		Quat4d q4d = move.getLastRotation();
		this.outputStream.writeDouble(q4d.x);
		this.outputStream.writeDouble(q4d.y);
		this.outputStream.writeDouble(q4d.z);
		this.outputStream.writeDouble(q4d.w);
		
		double linearVelocity = move.getCurrentLinearVelocity();
		double angularVelocity = move.getCurrentAngularVelocity();
		this.outputStream.writeDouble(linearVelocity);
		this.outputStream.writeDouble(angularVelocity);
		
		Point3d p3d = move.getPosition();
		this.outputStream.writeDouble(p3d.x);
		this.outputStream.writeDouble(p3d.y);
		this.outputStream.writeDouble(p3d.z);
		
		if (DEBUG) {
			System.err.println("\tmove="+vt3d.x+"; "+vt3d.y+"; "+vt3d.z); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
			System.err.println("\trotation="+q4d.x+"; "+q4d.y+"; "+q4d.z+"; "+q4d.w); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
			System.err.println("\tl.velocity="+linearVelocity); //$NON-NLS-1$
			System.err.println("\ta.velocity="+angularVelocity); //$NON-NLS-1$
			System.err.println("\tglobal position="+p3d.x+"; "+p3d.y+"; "+p3d.z); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		}
		
		q4d = move.getQuaternion();
		this.outputStream.writeDouble(q4d.x);
		this.outputStream.writeDouble(q4d.y);
		this.outputStream.writeDouble(q4d.z);
		this.outputStream.writeDouble(q4d.w);					
		
		if (DEBUG) {
			System.err.println("\tglobal orientation="+q4d.x+"; "+q4d.y+"; "+q4d.z+"; "+q4d.w); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
		}
	}

	/** Read a MOVE_ACTION content.
	 * 
	 * @return a move action.
	 * @throws IOException
	 */
	protected MobileEntityMoveInfo readMoveAction() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$

		int actionCode = this.inputStream.readByte();
		if (actionCode!=0) throw new IOException("unsupported action code: "+actionCode); //$NON-NLS-1$
		
		UUID entityId = readUUID();
		
		Vector3d linearMove = new Vector3d();
		linearMove.x = this.inputStream.readDouble();
		linearMove.y = this.inputStream.readDouble();
		linearMove.z = this.inputStream.readDouble();
		
		Quat4d angularMove = new Quat4d();
		angularMove.x = this.inputStream.readDouble();
		angularMove.y = this.inputStream.readDouble();
		angularMove.z = this.inputStream.readDouble();
		angularMove.w = this.inputStream.readDouble();
		
		double linearSpeed = this.inputStream.readDouble();
		double angularSpeed = this.inputStream.readDouble();
		
		Point3d position = new Point3d();
		position.x = this.inputStream.readDouble();
		position.y = this.inputStream.readDouble();
		position.z = this.inputStream.readDouble();
		
		Quat4d orientation = new Quat4d();
		orientation.x = this.inputStream.readDouble();
		orientation.y = this.inputStream.readDouble();
		orientation.z = this.inputStream.readDouble();
		orientation.w = this.inputStream.readDouble();
		
		return new MobileEntityMoveInfo(
				entityId, linearMove, angularMove,
				position, orientation,
				linearSpeed, angularSpeed);
	}

	/** Read the IDDLE message.
	 * 
	 * @param time is the simulation time
	 * @param duration is the duration of the last simulation step.
	 * @throws IOException
	 */
	protected void readIddleMessage(OutputParameter<Double> time, OutputParameter<Double> duration) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		time.set(this.inputStream.readDouble());
		duration.set(this.inputStream.readDouble());
	}

	/** Write the BYE message.
	 * 
	 * @throws IOException
	 */
	protected void writeByeMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.BYE);
		this.outputStream.flush();
	}
	
	/** Write the IAMVIEWER message.
	 * 
	 * @throws IOException
	 */
	protected void writeIamViewerMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.IAMVIEWER);
		this.outputStream.flush();
	}

	/** Write the IAMCONTROLLER message.
	 * 
	 * @throws IOException
	 */
	protected void writeIamControllerMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.IAMCONTROLLER);
		this.outputStream.flush();
	}

	/** Write the IAMBOTH message.
	 * 
	 * @throws IOException
	 */
	protected void writeIamBothMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.IAMBOTH);
		this.outputStream.flush();
	}

	/** Read the ADDITION message.
	 * 
	 * @param time is the simulation time
	 * @param entities is the list of descriptions the entities.
	 * @throws IOException
	 */
	protected void readAdditionMessage(OutputParameter<Double> time, ArrayList<MobileEntitySpawningInfo> entities) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		
		time.set(this.inputStream.readDouble());
		int entityCount = this.inputStream.readInt();
		
		MobileEntitySpawningInfo entity;
		
		entities.clear();
		entities.ensureCapacity(entityCount);
		
		for(int i=0; i<entityCount; ++i) {
			entity = readEntityDescriptionSection();
			entities.add(entity);
		}
	}

	/** Read the DELETION message.
	 * 
	 * @param time is the simulation time
	 * @param entityId is the identifier of the entity.
	 * @throws IOException
	 */
	protected void readDeletionMessage(OutputParameter<Double> time, OutputParameter<String> entityId) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		time.set(this.inputStream.readDouble());
		entityId.set(readString());
	}

	/** Read the MOVE_ACTION message.
	 * 
	 * @param time is the simulation time
	 * @param duration is the duration of the last simulation step.
	 * @param moves are the entity mobes
	 * @throws IOException
	 */
	protected void readMoveActionMessage(OutputParameter<Double> time, OutputParameter<Double> duration, OutputParameter<MobileEntityMoveInfo[]> moves) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		time.set(this.inputStream.readDouble());
		duration.set(this.inputStream.readDouble());
		
		int actionCount = this.inputStream.readInt();
		MobileEntityMoveInfo[] m = new MobileEntityMoveInfo[actionCount];
		for(int idxMove=0; idxMove<actionCount; ++idxMove) {
			m[idxMove] = readMoveAction();
		}
		moves.set(m);
	}

	/** Read the PROBE message.
	 * 
	 * @param time is the simulation time
	 * @param probes are the probed values
	 * @throws IOException
	 */
	protected void readProbeMessage(OutputParameter<Double> time, OutputParameter<ProbeInfo[]> probes) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		time.set(this.inputStream.readDouble());

		int probeCount = this.inputStream.readInt();
		ProbeInfo[] infos = new ProbeInfo[probeCount];
		String probeName;
		UUID placeId;
		int valueCount;
		Map<String,Object> values;
		OutputParameter<String> valueName = new OutputParameter<String>();
		OutputParameter<Object> valueObject = new OutputParameter<Object>();
		
		for(int idxProbe=0; idxProbe<probeCount; ++idxProbe) {
			placeId = readUUID();
			probeName = readString();
			
			valueCount = this.inputStream.readInt();
			values = new TreeMap<String, Object>();
			
			for(int idxValue=0; idxValue<valueCount; ++idxValue) {
				readVariant(valueName, valueObject);
				values.put(valueName.get(), valueObject.get());
			}
			
			infos[idxProbe] = new ProbeInfo(placeId, probeName, values);
		}
		
		probes.set(infos);
	}

	/** Read the START message.
	 * 
	 * @param simuInfo the simulation information
	 * @param placeInfo the place informations
	 * @throws IOException
	 */
	protected void readStartMessage(OutputParameter<SimulationInfo> simuInfo, OutputParameter<PlaceInfo[]> placeInfo) throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$

		UUID simulationId = readUUID();
		String simulationName = readString();
		Date creationDate = new Date(this.inputStream.readInt()*1000);
		String authors = readString();
		String version = readString();
		String description = readString();

		TimeUnit timeUnit;
		{
			byte unitCode = this.inputStream.readByte();
			switch(unitCode) {
			case 0:
				timeUnit = TimeUnit.NANOSECONDS;
				break;
			case 1:
				timeUnit = TimeUnit.MICROSECONDS;
				break;
			case 2:
				timeUnit = TimeUnit.MILLISECONDS;
				break;
			case 3:
				timeUnit = TimeUnit.SECONDS;
				break;
			case 4:
				timeUnit = TimeUnit.MINUTES;
				break;
			case 5:
				timeUnit = TimeUnit.HOURS;
				break;
			case 6:
				timeUnit = TimeUnit.DAYS;
				break;
			default:
				throw new IOException("unsupported time unit code: "+unitCode); //$NON-NLS-1$
			}
		}

		SpaceUnit spaceUnit;
		{
			byte unitCode = this.inputStream.readByte();
			switch(unitCode) {
			case 0:
				spaceUnit = SpaceUnit.MILLIMETER;
				break;
			case 1:
				spaceUnit = SpaceUnit.CENTIMETER;
				break;
			case 2:
				spaceUnit = SpaceUnit.DECIMETER;
				break;
			case 3:
				spaceUnit = SpaceUnit.METER;
				break;
			case 4:
				spaceUnit = SpaceUnit.DECAMETER;
				break;
			case 5:
				spaceUnit = SpaceUnit.KILOMETER;
				break;
			default:
				throw new IOException("unsupported space unit code: "+unitCode); //$NON-NLS-1$
			}
		}

		SpeedUnit speedUnit;
		{
			byte unitCode = this.inputStream.readByte();
			switch(unitCode) {
			case 0:
				speedUnit = SpeedUnit.MILLIMETERS_PER_SECOND;
				break;
			case 1:
				speedUnit = SpeedUnit.METERS_PER_SECOND;
				break;
			case 2:
				speedUnit = SpeedUnit.KILOMETERS_PER_HOUR;
				break;
			default:
				throw new IOException("unsupported linear speed unit code: "+unitCode); //$NON-NLS-1$
			}
		}

		AngularUnit angularUnit;
		{
			byte unitCode = this.inputStream.readByte();
			switch(unitCode) {
			case 0:
				angularUnit = AngularUnit.TURNS_PER_SECOND;
				break;
			case 1:
				angularUnit = AngularUnit.RADIANS_PER_SECOND;
				break;
			case 2:
				angularUnit = AngularUnit.DEGREES_PER_SECOND;
				break;
			default:
				throw new IOException("unsupported angular speed unit code: "+unitCode); //$NON-NLS-1$
			}
		}
		
		double ux = this.inputStream.readDouble();
		double uy = this.inputStream.readDouble();
		double uz = this.inputStream.readDouble();
		double vx = this.inputStream.readDouble();
		double vy = this.inputStream.readDouble();
		double vz = this.inputStream.readDouble();
		double lx = this.inputStream.readDouble();
		double ly = this.inputStream.readDouble();
		double lz = this.inputStream.readDouble();
		
		CoordinateSystem3D coordinateSystem = CoordinateSystem3D.fromVectors(
				vx, vy, vz, lx, ly, lz, ux, uy, uz);

		float spaceDimension = this.inputStream.readByte() / 10f;

		simuInfo.set(new SimulationInfo(
				simulationId, simulationName, creationDate, 
				authors, version, description,
				timeUnit, spaceUnit, speedUnit, angularUnit,
				vx, vy, vz, ux, uy, uz, lx, ly, lz, spaceDimension));
		
		// PLACES
		int placeCount = this.inputStream.readInt();		
		PlaceInfo[] places = new PlaceInfo[placeCount];		
		UUID placeId, groundId;
		String resourceName, placeName;
		double x, y, z;
		double minz, maxz;
		Point2d minp, maxp;
		int entityCount;
		Collection<MobileEntitySpawningInfo> entities = new ArrayList<MobileEntitySpawningInfo>();
		GroundInfo groundInfo;

		for(int idxPlace=0; idxPlace<placeCount; ++idxPlace) {
			
			placeId = readUUID();
			placeName = readString();
			groundId = readUUID();

			x = this.inputStream.readDouble();
			y = this.inputStream.readDouble();
			z = this.inputStream.readDouble();
			minp = coordinateSystem.toCoordinateSystem2D(new Point3d(x,y,z));
			minz = coordinateSystem.height(x, y, z);
						
			x = this.inputStream.readDouble();
			y = this.inputStream.readDouble();
			z = this.inputStream.readDouble();
			maxp = coordinateSystem.toCoordinateSystem2D(new Point3d(x,y,z));
			maxz = coordinateSystem.height(x, y, z);
			
			resourceName = readString();
			
			entityCount = this.inputStream.readInt();
			entities.clear();
			
			for(int idxEntity=0; idxEntity<entityCount; ++idxEntity) {
				entities.add(readEntityDescriptionSection());
			}
			

			groundInfo = new GroundInfo(groundId, 
					minp.x,minp.y,minz,maxp.x,maxp.y,maxz,
					resourceName);
			
			places[idxPlace] = new PlaceInfo(placeId, placeName, groundInfo, entities);
		}
		
		placeInfo.set(places);
	}

	/**
	 * Write the START Message.
	 * 
	 * @param config
	 * @param places
	 * @throws IOException
	 */
	protected void writeStartMessage(SimulationInfo config, PlaceInfo... places) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		
		writeHeaderSection(NetworkMessageType.START);
		
		writeUUID(config.getId());
		writeString(config.getName());
		
		{
			Date creationDate = config.getDate();
			this.outputStream.writeInt((int)(creationDate.getTime()/1000));
		}

		writeString(config.getAuthors());

		writeString(config.getVersion());

		writeString(config.getDescription());

		{
			TimeUnit unit = config.getTimeUnit();
			switch(unit) {
			case NANOSECONDS:
				this.outputStream.writeByte(0);
				break;
			case MICROSECONDS:
				this.outputStream.writeByte(1);
				break;
			case MILLISECONDS:
				this.outputStream.writeByte(2);
				break;
			case SECONDS:
				this.outputStream.writeByte(3);
				break;
			case MINUTES:
				this.outputStream.writeByte(4);
				break;
			case HOURS:
				this.outputStream.writeByte(5);
				break;
			case DAYS:
				this.outputStream.writeByte(6);
				break;
			default:
				throw new IOException("unsupported time unit: "+unit); //$NON-NLS-1$
			}
		}

		{
			SpaceUnit unit = config.getSpaceUnit();
			switch(unit) {
			case MILLIMETER:
				this.outputStream.writeByte(0);
				break;
			case CENTIMETER:
				this.outputStream.writeByte(1);
				break;
			case DECIMETER:
				this.outputStream.writeByte(2);
				break;
			case METER:
				this.outputStream.writeByte(3);
				break;
			case DECAMETER:
				this.outputStream.writeByte(4);
				break;
			case KILOMETER:
				this.outputStream.writeByte(5);
				break;
			default:
				throw new IOException("unsupported space unit: "+unit); //$NON-NLS-1$
			}
		}

		{
			SpeedUnit unit = config.getSpeedUnit();
			switch(unit) {
			case MILLIMETERS_PER_SECOND:
				this.outputStream.writeByte(0);
				break;
			case METERS_PER_SECOND:
				this.outputStream.writeByte(1);
				break;
			case KILOMETERS_PER_HOUR:
				this.outputStream.writeByte(2);
				break;
			default:
				throw new IOException("unsupported linear speed unit: "+unit); //$NON-NLS-1$
			}
		}

		{
			AngularUnit unit = config.getRotationSpeedUnit();
			switch(unit) {
			case TURNS_PER_SECOND:
				this.outputStream.writeByte(0);
				break;
			case RADIANS_PER_SECOND:
				this.outputStream.writeByte(1);
				break;
			case DEGREES_PER_SECOND:
				this.outputStream.writeByte(2);
				break;
			default:
				throw new IOException("unsupported angular speed unit: "+unit); //$NON-NLS-1$
			}
		}
		
		CoordinateSystem3D coordinateSystem = CoordinateSystem3D.fromVectors(
				config.getViewX(), config.getViewY(), config.getViewZ(),
				config.getLeftX(), config.getLeftY(), config.getLeftZ(),
				config.getUpX(), config.getUpY(), config.getUpZ());
		
		this.outputStream.writeDouble(config.getUpX());
		this.outputStream.writeDouble(config.getUpY());
		this.outputStream.writeDouble(config.getUpZ());
		this.outputStream.writeDouble(config.getViewX());
		this.outputStream.writeDouble(config.getViewY());
		this.outputStream.writeDouble(config.getViewZ());
		this.outputStream.writeDouble(config.getLeftX());
		this.outputStream.writeDouble(config.getLeftY());
		this.outputStream.writeDouble(config.getLeftZ());
		
		this.outputStream.writeByte((byte)(config.getSpaceDimension()*10));
		
		// PLACES
		this.outputStream.writeInt(places.length);
		
		Point2d pt2d;
		double height;
		Point3d pt3d_1, pt3d_2;
		GroundInfo ground;
		Collection<MobileEntitySpawningInfo> entities;
		
		for(PlaceInfo info : places) {
			
			writeUUID(info.getId());
			writeString(info.getName());
			
			ground = info.getGround();
			
			writeUUID(ground.getId());
			
			pt2d = ground.getMinPoint();
			height = ground.getMinHeight();
			pt3d_1 = coordinateSystem.fromCoordinateSystem2D(pt2d, height);
			
			pt2d = ground.getMaxPoint();
			height = ground.getMaxHeight();
			pt3d_2 = coordinateSystem.fromCoordinateSystem2D(pt2d, height);

			this.outputStream.writeDouble(Math.min(pt3d_1.x, pt3d_2.x));
			this.outputStream.writeDouble(Math.min(pt3d_1.y, pt3d_2.y));
			this.outputStream.writeDouble(Math.min(pt3d_1.z, pt3d_2.z));
			
			this.outputStream.writeDouble(Math.max(pt3d_1.x, pt3d_2.x));
			this.outputStream.writeDouble(Math.max(pt3d_1.y, pt3d_2.y));
			this.outputStream.writeDouble(Math.max(pt3d_1.z, pt3d_2.z));
			
			writeString(ground.getResourceName());
			
			entities = info.getEntities();
			
			if (entities==null) {
				this.outputStream.writeInt(0);
			}
			else {
				this.outputStream.writeInt(entities.size());
				
				for(MobileEntitySpawningInfo entity : entities) {

					writeEntityDescriptionSection(entity);
					
				}
			}
		}
		this.outputStream.flush();
	}

	/**
	 * Write the END Message.
	 * 
	 * @throws IOException
	 */
	protected void writeEndMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.END);
		this.outputStream.flush();
	}
	
	/**
	 * Write the MOVE_ACTION message.
	 *
	 * @param time is the simulation time at which the actions are done.
	 * @param duration is the duration of the last simulation step.
	 * @param actionCount is the count of actions replied by the iterator.
	 * @param entityMoves
	 * @throws IOException
	 */
	protected void writeMoveActionMessage(double time, double duration, int actionCount, Iterator<MobileEntityMoveInfo> entityMoves) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.ACTION);
		
		if (DEBUG) {
			System.err.println("\ttime="+time); //$NON-NLS-1$
			System.err.println("\tduration="+duration); //$NON-NLS-1$
		}

		this.outputStream.writeDouble(time);
		this.outputStream.writeDouble(duration);
		
		this.outputStream.writeInt(actionCount);
		
		MobileEntityMoveInfo info;
		int count = 0;
		
		while (entityMoves.hasNext()) {
			info = entityMoves.next();
			writeMoveActionSection(count, info);
			count ++;
		}

		if (count!=actionCount) throw new IOException("unexpected action count: "+actionCount+", expected: "+count); //$NON-NLS-1$ //$NON-NLS-2$
		this.outputStream.flush();
	}

	/**
	 * Write the IDDLE message.
	 *
	 * @param time is the simulation time at which the actions are done.
	 * @param duration is the duration of the last simulation step.
	 * @throws IOException
	 * @since 3.0
	 */
	protected void writeIddleMessage(double time, double duration) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.IDDLE);
		
		if (DEBUG) {
			System.err.println("\ttime="+time); //$NON-NLS-1$
			System.err.println("\tduration="+duration); //$NON-NLS-1$
		}

		this.outputStream.writeDouble(time);
		this.outputStream.writeDouble(duration);
	}

	/**
	 * Write the ADDITION message.
	 *
	 * @param time is the simulation time at which the addition was done.
	 * @param entityCount is the count of entities which will be replied by the iterator.
	 * @param entities
	 * @throws IOException
	 */
	protected void writeAdditionMessage(double time, int entityCount, Iterator<MobileEntitySpawningInfo> entities) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.ADDITION);
		this.outputStream.writeDouble(time);
		this.outputStream.writeInt(entityCount);
		int count = 0;
		MobileEntitySpawningInfo entity;
		while (entities.hasNext()) {
			entity = entities.next();
			writeEntityDescriptionSection(entity);
			++count;
		}
		if (count!=entityCount) throw new IOException("unexpected entity count: "+entityCount+", expected: "+count); //$NON-NLS-1$ //$NON-NLS-2$
		this.outputStream.flush();
	}

	/**
	 * Write the DELETION message.
	 *
	 * @param time is the simulation time at which the deletion was done.
	 * @param entityCount is the count of entities which will be replied by the iterator.
	 * @param entityId is the identifier of the entity.
	 * @throws IOException
	 */
	protected void writeDeletionMessage(double time, int entityCount, Iterator<UUID> entityId) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.DELETION);
		this.outputStream.writeDouble(time);
		this.outputStream.writeInt(entityCount);
		UUID id;
		int count = 0;
		while (entityId.hasNext()) {
			id = entityId.next();
			writeUUID(id);
			++count;
		}
		if (count!=entityCount) throw new IOException("unexpected entity count: "+entityCount+", expected: "+count); //$NON-NLS-1$ //$NON-NLS-2$
		this.outputStream.flush();
	}

	/**
	 * Build a PROBE message.
	 *
	 * @param time is the simulation time at which the deletion was done.
	 * @param probeCount is the count of probes replied by the iterator.
	 * @param probes are the probed values to send
	 * @throws IOException
	 */
	protected void writeProbeMessage(double time, int probeCount, Iterator<ProbeInfo> probes) throws IOException {
		writeHeaderSection(NetworkMessageType.PROBE);
		
		this.outputStream.writeDouble(time);
		
		this.outputStream.writeInt(probeCount);
		
		ProbeIdentifier id;
		Map<String,Object> values;
		int count = 0;
		ProbeInfo info;
		
		while (probes.hasNext()) {
			info = probes.next();

			id = info.getProbeIdentifier();
			writeUUID(id.getPlaceId());
			writeString(id.getProbeName());
		
			values = info.getProbedValues();
		
			if (values==null || values.isEmpty()) {
				this.outputStream.writeInt(0);
			}
			else {
				this.outputStream.writeInt(values.size());
				
				for(Entry<String,Object> entry : values.entrySet()) {
					writeVariant(entry.getKey(), entry.getValue());
				}
			}
			
			count ++;
		}
		if (count!=probeCount) throw new IOException("unexpected probe count: "+probeCount+", expected: "+count); //$NON-NLS-1$ //$NON-NLS-2$
		this.outputStream.flush();
	}

	/** Write the PLAY message.
	 * 
	 * @throws IOException
	 */
	protected void writePlayMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.PLAY);
		this.outputStream.flush();
	}

	/** Write the STEP message.
	 * 
	 * @throws IOException
	 */
	protected void writeStepMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.STEP);
		this.outputStream.flush();
	}

	/** Write the PAUSE message.
	 * 
	 * @throws IOException
	 */
	protected void writePauseMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.PAUSE);
		this.outputStream.flush();
	}

	/** Write the STOP message.
	 * 
	 * @throws IOException
	 */
	protected void writeStopMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.STOP);
		this.outputStream.flush();
	}

	/** Write the KILLED message.
	 * 
	 * @throws IOException
	 */
	protected void writeKilledMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.KILLED);
		this.outputStream.flush();
	}

	/** Write the KILL_SIMULATOR message.
	 * 
	 * @throws IOException
	 */
	protected void writeKillSimulatorMessage() throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.KILL_SIMULATOR);
		this.outputStream.flush();
	}

	/** Write the SET_SIMULATION_DELAY message.
	 *  
	 * @param delay
	 * @throws IOException
	 */
	protected void writeSetSimulationDelayMessage(int delay) throws IOException {
		if (this.outputStream==null) throw new BindException("no output socket"); //$NON-NLS-1$
		writeHeaderSection(NetworkMessageType.SET_SIMULATION_DELAY);
		this.outputStream.writeInt(delay);
		this.outputStream.flush();
	}

	/** Read a SET_SIMULATION_DELAY message's variable-length part.
	 *  
	 * @return the delay in milliseconds.
	 * @throws IOException
	 */
	protected int readSetSimulationDelayMessage() throws IOException {
		if (this.inputStream==null) throw new BindException("no input socket"); //$NON-NLS-1$
		return this.inputStream.readInt();
	}

}

